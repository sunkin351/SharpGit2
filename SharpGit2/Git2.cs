using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Text;

using CommunityToolkit.HighPerformance.Buffers;

using static SharpGit2.GitNativeApi;

[assembly: InternalsVisibleTo("SharpGit2.Tests")]
[assembly: DisableRuntimeMarshalling]

namespace SharpGit2;

public static unsafe partial class Git2
{
    internal const string LibraryName = "git2";

    internal const GitError ForEachBreak = (GitError)1;
    internal const GitError ForEachException = GitError.User;

    /// <summary>
    /// Minimum length (in number of hex characters, i.e. packets of 4 bits) of an oid prefix
    /// </summary>
    public static int ObjectIDMinPrefixLength => 4; // This is a property to allow future updates without having consumers need to recompile their code.

    public static Version NativeLibraryVersion { get; } = GetVersion();

    private static Version GetVersion()
    {
        int major, minor, rev;
        Git2.ThrowIfError(GitNativeApi.git_libgit2_version(&major, &minor, &rev));

        return new Version(major, minor, rev);
    }

    public static GitFeatures NativeLibraryFeatures { get; } = GitNativeApi.git_libgit2_features();

    public static string PathListSeparator
    {
        get
        {
            if (OperatingSystem.IsWindows())
            {
                return ";";
            }
            else
            {
                return ":";
            }
        }
    }

    public static string? GlobalConfigFile { get; } = GetPathFromFunction(&GitNativeApi.git_config_find_global, nameof(GlobalConfigFile));
    public static string? ProgramDataConfigFile { get; } = GetPathFromFunction(&GitNativeApi.git_config_find_programdata, nameof(ProgramDataConfigFile));
    public static string? SystemConfigFile { get; } = GetPathFromFunction(&GitNativeApi.git_config_find_system, nameof(SystemConfigFile));
    public static string? XDGConfigFile { get; } = GetPathFromFunction(&GitNativeApi.git_config_find_xdg, nameof(XDGConfigFile));

    internal static StringPool StringPool { get; } = new StringPool();

    private static string? GetPathFromFunction(delegate* managed<Native.GitBuffer*, GitError> func, string propertyName)
    {
        Native.GitBuffer buffer = default;
        var error = func(&buffer);

        switch (error)
        {
            case GitError.OK:
                try
                {
                    return buffer.AsString();
                }
                finally
                {
                    GitNativeApi.git_buf_dispose(&buffer);
                }
            case GitError.NotFound:
                return null;
            default:
                throw ExceptionForError(error, propertyName);
        }
    }

    /// <summary>
    /// Returns the last error generated by the current thread.
    /// </summary>
    /// <returns>The last error's details</returns>
    /// <remarks>
    /// Do not use to determine if an error was produced, that's what API return values are for.
    /// <br/><br/>
    /// Intended to be used when calling <see cref="GitNativeApi"/> functions directly, as those don't throw on error.
    /// </remarks>
    public static (string Message, GitErrorClass ErrorClass)? GetLastError()
    {
        var err = git_error_last();

        return err is null ? null : (Utf8StringMarshaller.ConvertToManaged(err->Message)!, err->Class);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static Exception ExceptionForError(GitError error, [CallerMemberName] string? callerName = null)
    {
        ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual((int)error, 0);

        var (message, klass) = GetLastError() ??
            (error == GitError.NotSupported ? "LibGit2 has returned that it does not support this operation!" : "LibGit2 has returned an error!", GitErrorClass.None);

        return error switch
        {
            GitError.NotSupported => new NotSupportedException($"{callerName}: {message}"),
            _ => new Git2Exception(error, klass, $"{callerName}: {message}"),
        };
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="code"></param>
    /// <param name="callerName"></param>
    /// <exception cref="Git2Exception"/>
    internal static void ThrowError(GitError code, [CallerMemberName] string? callerName = null)
    {
        throw ExceptionForError(code, callerName);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="code"></param>
    /// <param name="callerName"></param>
    /// <exception cref="Git2Exception"/>
    internal static void ThrowIfError(GitError code, [CallerMemberName] string? callerName = null)
    {
        if (code < 0)
            ThrowError(code, callerName);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="code"></param>
    /// <param name="callerName"></param>
    /// <exception cref="Git2Exception"/>
    internal static bool ErrorOrBoolean(int code, [CallerMemberName] string? callerName = null)
    {
        if (code < 0)
            ThrowError((GitError)code, callerName);

        return code != 0;
    }

    public static GitDescribeResult DescribeCommit(GitObject committish, in GitDescribeOptions options)
    {
        committish.ThrowIfNull();

        DescribeResult* result = null;
        GitError error;

        Native.GitDescribeOptions _options = default;
        List<GCHandle> gchandles = [];
        try
        {
            _options.FromManaged(in options, gchandles);

            error = git_describe_commit(&result, committish.NativeHandle, &_options);
        }
        finally
        {
            foreach (var handle in gchandles)
            {
                handle.Free();
            }

            _options.Free();
        }

        ThrowIfError(error);

        return new(result);
    }

    public static GitDescribeResult DescribeCommit(this GitCommit commit, in GitDescribeOptions options)
    {
        return DescribeCommit(commit, in options);
    }

    public static GitDescribeResult DescribeCommit(this GitTag tag, in GitDescribeOptions options)
    {
        return DescribeCommit(tag, in options);
    }

    internal static string GetPooledString(byte* nativeString)
    {
        return StringPool.GetOrAdd(MemoryMarshal.CreateReadOnlySpanFromNullTerminated(nativeString), Encoding.UTF8);
    }

    internal static string GetPooledString(ReadOnlySpan<byte> nativeString)
    {
        return StringPool.GetOrAdd(nativeString, Encoding.UTF8);
    }

    public static void AddPooledString(string value)
    {
        StringPool.Add(value);
    }

    /// <summary>
    /// Null check to make absolutely sure the provided handle is not null
    /// </summary>
    /// <typeparam name="THandle"></typeparam>
    /// <param name="handle"></param>
    /// <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static THandle ThrowIfNull<THandle>(this THandle handle) where THandle : struct, IGitHandle
    {
        if (handle.IsNull)
            ThrowNull();

        return handle;
    }

    private static void ThrowNull()
    {
        throw new NullReferenceException("Git Object Handle not set to an instance of an object!");
    }

    /// <summary>
    /// An array of commit objects returned by libgit2.
    /// </summary>
    /// <remarks>
    /// Lifetime of containing Commit objects is tied to the lifetime of the array.
    /// <br/>
    /// Do not dispose of the underlying objects, and only dispose of the array when you are done with all objects in the array.
    /// </remarks>
    public struct CommitArray : IDisposable
    {
        internal Git2.Commit** commits;
        internal nuint count;

        public readonly ReadOnlySpan<GitCommit> Span
        {
            get
            {
                Debug.Assert(sizeof(GitCommit) == sizeof(Git2.Commit*));

                return new(commits, checked((int)count));
            }
        }

        public readonly nuint Count => count;

        public readonly GitCommit this[nuint i]
        {
            get
            {
                ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(i, this.Count);

                return new(commits[i]);
            }
        }

        public void Dispose()
        {
            if (commits == null)
                return;

            var copy = this;

            GitNativeApi.git_commitarray_dispose(&copy);

            this = default;
        }
    }

    #region Opaque Handles
    public struct AnnotatedCommit { }
    public struct Blame { }
    public struct Blob { }
    public struct BranchIterator { }
    public struct Certificate { }
    public struct Commit { }
    public struct CommitGraph { }
    public struct Config { }
    public struct ConfigBackend { }
    public struct ConfigIterator { }
    public struct Credential { }
    public struct DescribeResult { }
    public struct Diff { }
    public struct DiffStats { }
    public struct FilterList { }
    public struct Index { }
    public struct Indexer { }
    public struct IndexConflictIterator { }
    public struct IndexIterator { }
    public struct MailMap { }
    public struct Note { }
    public struct NoteIterator { }
    public struct Object { }
    public struct ObjectDatabase { }
    public struct ObjectDatabaseBackend { }
    public struct ObjectDatabaseObject { }
    public struct PackBuilder { }
    public struct Patch { }
    public struct PathSpec { }
    public struct PathSpecMatchList { }
    public struct Rebase { }
    public struct Reference { }
    public struct ReferenceIterator { }
    public struct ReferenceDatabase { }
    public struct RefLog { }
    public struct RefLogEntry { }
    public struct RefSpec { }
    public struct Remote { }
    public struct Repository { }
    public struct RevWalk { }
    public struct StatusList { }
    public struct Submodule { }
    public struct Tag { }
    public struct Transaction { }
    public struct Transport { }
    public struct Tree { }
    public struct TreeBuilder { }
    public struct TreeEntry { }
    public struct Worktree { }

    #endregion

    [method: SetsRequiredMembers]
    internal ref struct CallbackContext<TCallback>(TCallback callback) where TCallback : class
    {
        public required TCallback Callback { get; init; } = callback;

        internal ExceptionDispatchInfo? ExceptionInfo { get; set; }
    }

    public readonly record struct Version : IComparable<Version>, ISpanFormattable
    {
        private readonly uint _version;

        public int Major { get => (int)(_version >> 20); }
        public int Minor { get => (int)((_version >> 10) & 0x03FF); }
        public int Revision { get => (int)(_version & 0x03FF); }

        public Version(int major, int minor, int revision)
        {
            ArgumentOutOfRangeException.ThrowIfNegative(major);
            ArgumentOutOfRangeException.ThrowIfNegative(minor);
            ArgumentOutOfRangeException.ThrowIfNegative(revision);
            ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(major, 1 << 12);
            ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(minor, 1 << 10);
            ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(revision, 1 << 10);

            _version = (uint)((major << 20) | (minor << 10) | revision);
        }

        public int CompareTo(Version other)
        {
            return this._version.CompareTo(other._version);
        }

        public static bool operator <(Version a, Version b)
        {
            return a._version < b._version;
        }

        public static bool operator >(Version a, Version b)
        {
            return a._version > b._version;
        }

        public static bool operator <=(Version a, Version b)
        {
            return a._version <= b._version;
        }

        public static bool operator >=(Version a, Version b)
        {
            return a._version >= b._version;
        }

        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            return destination.TryWrite($"v{Major}.{Minor}.{Revision}", out charsWritten);
        }

        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            return $"v{Major}.{Minor}.{Revision}";
        }

        public override string ToString()
        {
            return ToString(null, null);
        }
    }
}
